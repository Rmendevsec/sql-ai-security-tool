import requests
import json
import threading
import argparse
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urljoin, urlparse
import sys
import time
import random
import re
from bs4 import BeautifulSoup

class VulnerabilityScanner:
    def __init__(self, target_file=None, target_url=None, threads=10, timeout=10):
        self.targets = self.load_targets(target_file, target_url)
        self.threads = threads
        self.timeout = timeout
        self.vulnerabilities = []
        self.session = requests.Session()
        self.lock = threading.Lock()
        
        # Setup session headers
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
    
    def load_targets(self, target_file, target_url):
        """Load targets from file or single URL"""
        targets = []
        if target_url:
            targets.append(target_url)
        if target_file:
            try:
                with open(target_file, 'r') as f:
                    targets.extend([line.strip() for line in f if line.strip()])
            except FileNotFoundError:
                print(f"Target file {target_file} not found!")
                sys.exit(1)
        return list(set(targets))  # Remove duplicates
    
    def log_vulnerability(self, target, vulnerability_type, details, severity="MEDIUM"):
        """Log discovered vulnerabilities"""
        vulnerability = {
            'target': target,
            'type': vulnerability_type,
            'details': details,
            'severity': severity,
            'timestamp': time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        with self.lock:
            self.vulnerabilities.append(vulnerability)
            print(f"\033[91m[!] {severity}: {vulnerability_type} found at {target}\033[0m")
            print(f"     Details: {details}")
    
    def test_sql_injection(self, url):
        """Test for SQL Injection vulnerabilities"""
        print(f"Testing SQLi on: {url}")
        
        # SQL injection payloads
        sqli_payloads = [
            "'",
            "';",
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT 1,2,3--",
            "' AND 1=2 UNION SELECT 1,2,3--",
            "' OR SLEEP(5)--",
        ]
        
        error_indicators = [
            "sql syntax",
            "mysql_fetch",
            "ora-",
            "microsoft odbc",
            "postgresql",
            "sqlite",
            "warning: mysql",
            "unclosed quotation mark",
        ]
        
        # Test in URL parameters
        if '?' in url:
            for payload in sqli_payloads:
                try:
                    test_url = url + payload
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check for SQL errors in response
                    content_lower = response.text.lower()
                    if any(indicator in content_lower for indicator in error_indicators):
                        self.log_vulnerability(
                            url, 
                            "SQL Injection", 
                            f"Parameter vulnerable to: {payload}",
                            "HIGH"
                        )
                        break
                        
                except Exception as e:
                    pass
    
    def test_xss(self, url):
        """Test for Cross-Site Scripting vulnerabilities"""
        print(f"Testing XSS on: {url}")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "\"><script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
        ]
        
        if '?' in url:
            for payload in xss_payloads:
                try:
                    test_url = url + payload
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        self.log_vulnerability(
                            url,
                            "Cross-Site Scripting (XSS)",
                            f"Reflected XSS with: {payload}",
                            "MEDIUM"
                        )
                        break
                        
                except Exception as e:
                    pass
    
    def test_directory_traversal(self, url):
        """Test for Directory Traversal vulnerabilities"""
        print(f"Testing Directory Traversal on: {url}")
        
        traversal_payloads = [
            "../../../../etc/passwd",
            "..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "../../../../etc/shadow",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        ]
        
        indicators = {
            "root:x:0:0": "/etc/passwd",
            "root:*": "/etc/shadow", 
            "Copyright (c)": "Windows hosts",
        }
        
        base_url = url.split('?')[0] if '?' in url else url
        
        for payload in traversal_payloads:
            try:
                if '?' in url:
                    test_url = url + payload
                else:
                    test_url = f"{base_url}?file={payload}"
                
                response = self.session.get(test_url, timeout=self.timeout)
                
                for indicator, file_type in indicators.items():
                    if indicator in response.text:
                        self.log_vulnerability(
                            url,
                            "Directory Traversal",
                            f"Can read {file_type} with: {payload}",
                            "HIGH"
                        )
                        return
                        
            except Exception as e:
                pass
    
    def test_command_injection(self, url):
        """Test for Command Injection vulnerabilities"""
        print(f"Testing Command Injection on: {url}")
        
        cmd_payloads = [
            ";id",
            "|id",
            "&&id",
            "||id",
            "`id`",
            "$(id)",
        ]
        
        if '?' in url:
            for payload in cmd_payloads:
                try:
                    test_url = url + payload
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check for command output indicators
                    if "uid=" in response.text or "gid=" in response.text:
                        self.log_vulnerability(
                            url,
                            "Command Injection", 
                            f"OS command execution with: {payload}",
                            "CRITICAL"
                        )
                        break
                        
                except Exception as e:
                    pass
    
    def test_sensitive_files(self, base_url):
        """Test for exposed sensitive files"""
        print(f"Testing sensitive files on: {base_url}")
        
        sensitive_files = [
            ".env", ".git/config", ".htaccess", ".htpasswd",
            "backup.zip", "dump.sql", "config.php", "config.json",
            "admin.php", "administrator", "phpinfo.php", "test.php",
            "robots.txt", "crossdomain.xml", "clientaccesspolicy.xml",
            "web.config", "server-status", "debug.log", "error.log",
        ]
        
        for file_path in sensitive_files:
            try:
                test_url = urljoin(base_url, file_path)
                response = self.session.get(test_url, timeout=self.timeout)
                
                if response.status_code == 200:
                    content_length = len(response.content)
                    
                    # Check for interesting content
                    if content_length > 0:
                        self.log_vulnerability(
                            base_url,
                            "Exposed Sensitive File",
                            f"Found: {file_path} (Size: {content_length} bytes)",
                            "MEDIUM" if file_path in ['.env', 'config.php'] else "LOW"
                        )
                        
            except Exception as e:
                pass
    
    def test_http_methods(self, url):
        """Test for dangerous HTTP methods"""
        print(f"Testing HTTP methods on: {url}")
        
        dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'CONNECT']
        
        for method in dangerous_methods:
            try:
                response = self.session.request(method, url, timeout=self.timeout)
                
                if response.status_code in [200, 201, 202, 204]:
                    self.log_vulnerability(
                        url,
                        "Dangerous HTTP Method Enabled",
                        f"Method {method} allowed (Status: {response.status_code})",
                        "MEDIUM"
                    )
                    
            except Exception as e:
                pass
    
    def test_info_disclosure(self, url):
        """Test for information disclosure"""
        print(f"Testing info disclosure on: {url}")
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            headers = response.headers
            
            # Check headers for information disclosure
            info_headers = {
                'Server': 'Web server version disclosure',
                'X-Powered-By': 'Technology disclosure',
                'X-AspNet-Version': 'ASP.NET version disclosure',
                'X-Runtime': 'Runtime information',
            }
            
            for header, description in info_headers.items():
                if header in headers:
                    self.log_vulnerability(
                        url,
                        "Information Disclosure",
                        f"{description}: {headers[header]}",
                        "LOW"
                    )
            
            # Check response body for sensitive information
            sensitive_patterns = {
                r'password.*[\'\"][^\'\"]*[\'\"]': 'Hardcoded password',
                r'api_key.*[\'\"][^\'\"]*[\'\"]': 'API key exposure',
                r'token.*[\'\"][^\'\"]*[\'\"]': 'Token exposure', 
                r'email.*@.*\..*': 'Email address exposure',
                r'(\d{1,3}\.){3}\d{1,3}': 'IP address exposure',
            }
            
            for pattern, issue in sensitive_patterns.items():
                if re.search(pattern, response.text, re.IGNORECASE):
                    self.log_vulnerability(
                        url,
                        "Sensitive Information Disclosure",
                        f"Found {issue} in response body",
                        "MEDIUM"
                    )
                    
        except Exception as e:
            pass
    
    def scan_target(self, target):
        """Run all vulnerability tests on a single target"""
        print(f"\n\033[94m[*] Scanning: {target}\033[0m")
        
        # Normalize URL
        if not target.startswith(('http://', 'https://')):
            target = 'http://' + target
        
        try:
            # Test various vulnerabilities
            self.test_sql_injection(target)
            self.test_xss(target)
            self.test_directory_traversal(target)
            self.test_command_injection(target)
            self.test_sensitive_files(target)
            self.test_http_methods(target)
            self.test_info_disclosure(target)
            
        except Exception as e:
            print(f"Error scanning {target}: {e}")
    
    def run_scan(self):
        """Run vulnerability scan on all targets"""
        print(f"Starting vulnerability scan on {len(self.targets)} targets...")
        print("=" * 60)
        
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.scan_target, self.targets)
        
        end_time = time.time()
        
        # Print summary
        self.print_summary(start_time, end_time)
    
    def print_summary(self, start_time, end_time):
        """Print scan summary"""
        print("\n" + "=" * 60)
        print("SCAN SUMMARY")
        print("=" * 60)
        print(f"Scan duration: {end_time - start_time:.2f} seconds")
        print(f"Targets scanned: {len(self.targets)}")
        print(f"Vulnerabilities found: {len(self.vulnerabilities)}")
        
        # Group by severity
        severity_count = {}
        for vuln in self.vulnerabilities:
            severity = vuln['severity']
            severity_count[severity] = severity_count.get(severity, 0) + 1
        
        print("\nVulnerabilities by severity:")
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            count = severity_count.get(severity, 0)
            color = {
                'CRITICAL': '\033[91m',
                'HIGH': '\033[91m', 
                'MEDIUM': '\033[93m',
                'LOW': '\033[92m'
            }.get(severity, '\033[0m')
            print(f"  {color}{severity}: {count}\033[0m")
        
        # Print all vulnerabilities
        if self.vulnerabilities:
            print("\nDetailed findings:")
            for vuln in self.vulnerabilities:
                color = {
                    'CRITICAL': '\033[91m',
                    'HIGH': '\033[91m',
                    'MEDIUM': '\033[93m', 
                    'LOW': '\033[92m'
                }.get(vuln['severity'], '\033[0m')
                print(f"{color}[{vuln['severity']}] {vuln['type']} at {vuln['target']}\033[0m")
                print(f"     {vuln['details']}")

def main():
    parser = argparse.ArgumentParser(description='Vulnerability Scanner')
    parser.add_argument('-u', '--url', help='Single target URL')
    parser.add_argument('-f', '--file', help='File containing list of URLs')
    parser.add_argument('-t', '--threads', type=int, default=10, help='Number of threads')
    parser.add_argument('-T', '--timeout', type=int, default=10, help='Request timeout')
    parser.add_argument('-o', '--output', help='Output file for results')
    
    args = parser.parse_args()
    
    if not args.url and not args.file:
        print("Error: Either --url or --file must be specified")
        sys.exit(1)
    
    scanner = VulnerabilityScanner(args.file, args.url, args.threads, args.timeout)
    scanner.run_scan()
    
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(scanner.vulnerabilities, f, indent=2)
        print(f"\nResults saved to: {args.output}")

if __name__ == "__main__":
    main()